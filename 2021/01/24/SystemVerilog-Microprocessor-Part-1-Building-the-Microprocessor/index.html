<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>SystemVerilog Microprocessor Part 1 - Building the Microprocessor | Butty Builds</title>
  
  
  
  <!--link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css"-->
  
<link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css">

  
<link rel="stylesheet" href="/css/style.css">

</head>

<body>
<div class="Shell">
    <aside class='SideBar'>
    <section class='avatar' style="background-image: url(/assets/header.jpg)">
        <div class='av-pic' style="background-image: url(/assets/gremlin.jpg)">
        </div>
    </section>
    <section class='menu'>
        <div>Butty Builds</div>
        
        <ul>
          
            <a href="/" class="Btn">
              <li>Home</li>
            </a>  
          
            <a href="/about/" class="Btn">
              <li>About</li>
            </a>  
          
            <a href="/logbooks/" class="Btn">
              <li>Logbooks</li>
            </a>  
          
            <a href="/archives/" class="Btn">
              <li>Archive</li>
            </a>  
          
        </ul>
    </section>
    <section class="media">
        
    </section>
</aside>

    <div class="container">
        <div data-pager-shell>
            <div>
  <article class='ContentView'>
    <header class='PageTitle'>
        <h1>SystemVerilog Microprocessor Part 1 - Building the Microprocessor</h1>
    </header>

    <section>
      <h3 id="Microprocessor-Architecture"><a href="#Microprocessor-Architecture" class="headerlink" title="Microprocessor Architecture"></a>Microprocessor Architecture</h3><p style="text-align:center;"><img src="/images/sv-microprocessor/IMG_20210123_152930.jpg" alt="CPU Architecture" style="width: 50%; height: 50%">

</p><p>PC:<br>The program counter is a sequential logic module that records the position of the program through the ROM and outputs the position to the sysbus when the next instruction needs to be loaded.</p>
<p>IR:<br>The instruction register is a sequential logic module that reads the opcode from the sysbus and passes it to the sequencer.</p>
<p>Sequencer:<br>The sequencer is a state machine that controls the order of operation for the other modules. This is important to stop any bus contention occurring.</p>
<p style="text-align:center;"><img src="/images/sv-microprocessor/IMG_20210123_151328.jpg" alt="Sequencer ASM Chart" style="width: 50%; height: 50%">

</p><h3 id="Memory-Mapped-Input-and-Output"><a href="#Memory-Mapped-Input-and-Output" class="headerlink" title="Memory Mapped Input and Output"></a>Memory Mapped Input and Output</h3><p>A buffer and a register were now instantiated so that these could be used as input and output to the Microcontroller</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//instantiate 1 register and 1 buffer here</span></span><br><span class="line">buffer <span class="variable">#(.WORD_W(WORD_W), .OP_W(OP_W)) b1 (.*)</span>;</span><br><span class="line">sequencer <span class="variable">#(.WORD_W(WORD_W), .OP_W(OP_W)) s1 (.*)</span>;</span><br><span class="line">ir <span class="variable">#(.WORD_W(WORD_W), .OP_W(OP_W)) i1 (.*)</span>;</span><br><span class="line">pc <span class="variable">#(.WORD_W(WORD_W), .OP_W(OP_W)) p1 (.*)</span>;</span><br><span class="line">alu <span class="variable">#(.WORD_W(WORD_W), .OP_W(OP_W)) a1 (.*)</span>;</span><br><span class="line">ram <span class="variable">#(.WORD_W(WORD_W), .OP_W(OP_W)) r1 (.*)</span>;</span><br><span class="line">rom <span class="variable">#(.WORD_W(WORD_W), .OP_W(OP_W)) r2 (.*)</span>;</span><br><span class="line">register <span class="variable">#(.WORD_W(WORD_W), .OP_W(OP_W)) r3 (.*)</span>;</span><br></pre></td></tr></table></figure>

<p>The memory, going from address 0 to address 31, should now be connected to these applications.</p>
<p style="text-align:center;"><img src="/images/sv-microprocessor/Memory.png" alt="Memory addresses" style="width: 50%; height: 50%">

</p><p>However, if the CPU attempts to read from address 30, both the buffer and the RAM will be enabled. This is a problem as both RAM and the buffer will assert their values onto the sysbus as they are both being read. The two values on the same bus will interfere with each other giving a signal that is likely neither of them. This is bus contention.</p>
<p>Modifying this line so that mdr is not written to the bus when mar contains addresses 30 or 31.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//The following line in the ram module copies the contents of mdr to sysbus:</span></span><br><span class="line"><span class="keyword">assign</span> sysbus = (MDR_bus &amp; mar[WORD_W-OP_W-<span class="number">1</span>]</span><br><span class="line"> &amp; ~(mar==<span class="number">30</span> | mar==<span class="number">31</span>)) ? mdr : &#x27;z ; </span><br></pre></td></tr></table></figure>

<p>Modifying the testbench, I made switches and displays as variables</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> testcpu;</span><br><span class="line"><span class="keyword">parameter</span> <span class="keyword">int</span> WORD_W = <span class="number">8</span>, OP_W = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">logic</span> clock, n_reset;</span><br><span class="line"><span class="keyword">logic</span> [WORD_W-<span class="number">1</span>:<span class="number">0</span>] switches;</span><br><span class="line"><span class="keyword">logic</span> [WORD_W-<span class="number">1</span>:<span class="number">0</span>] display;</span><br><span class="line"><span class="keyword">wire</span> [WORD_W-<span class="number">1</span>:<span class="number">0</span>] sysbus;</span><br></pre></td></tr></table></figure>

<p>Simulating my testbench and microprocessor in Modelsim I got this output for my variables.<br><img src="/images/sv-microprocessor/waveform1.png" alt="Modelsim output" style="width: 100%; height: 100%"></p>
<p>Both the display register and the switches are of unknown value as they are not defined at any point in the testbench or the program.</p>
<p>I modified the program in the rom module such that the result in the accumulator is STOREd to address 31 (display) as well as address 16.</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cpu2 <span class="variable">#(.WORD_W(WORD_W), .OP_W(OP_W)) c1 (.*)</span>;</span><br><span class="line"> <span class="number">0</span>: mdr = &#123;<span class="meta">`STORE, 5&#x27;d16 &#125;; //Store the contents of accumulator</span></span><br><span class="line"> <span class="number">1</span>: mdr = &#123;<span class="meta">`LOAD, 5&#x27;d16 &#125;; //Load the contents of address into the accumulator</span></span><br><span class="line"> <span class="number">2</span>: mdr = &#123;<span class="meta">`ADD, 5&#x27;d6 &#125;; //Add the contents of address to the accumulator</span></span><br><span class="line"> <span class="number">3</span>: mdr = &#123;<span class="meta">`STORE, 5&#x27;d16 &#125;; //Store the contents of accumulator</span></span><br><span class="line"> <span class="number">4</span>: mdr = &#123;<span class="meta">`STORE, 5&#x27;d31 &#125;; //Store the contents of accumulator</span></span><br><span class="line"> <span class="number">5</span>: mdr = &#123;<span class="meta">`BNE, 5&#x27;d7 &#125;; //Branch if result of last arithmetic operation is not zero</span></span><br><span class="line"> <span class="number">6</span>: mdr = <span class="number">2</span>; <span class="comment">//contents used by another instruction</span></span><br><span class="line"> <span class="number">7</span>: mdr = <span class="number">1</span>; <span class="comment">//contents used by another instruction</span></span><br></pre></td></tr></table></figure>

<p>My modified program would output the value to the display register. This clearly shows the<br>program counts up in twos.</p>
<img src="/images/sv-microprocessor/waveform2.png" alt="Modelsim output" style="width: 100%; height: 100%">

<p>I then made a second change to the program in the rom module such that the data for the ADD operation comes from address 30 – the switches. In addition I also modified “testcpu” to apply different values to the switches during the simulation. </p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: mdr = &#123;<span class="meta">`STORE, 5&#x27;d16 &#125;; //Store the contents of accumulator</span></span><br><span class="line"><span class="number">1</span>: mdr = &#123;<span class="meta">`LOAD, 5&#x27;d16 &#125;; //Load the contents of address into the accumulator</span></span><br><span class="line"><span class="number">2</span>: mdr = &#123;<span class="meta">`ADD, 5&#x27;d30 &#125;; //Add the contents of address to the accumulator</span></span><br><span class="line"><span class="number">3</span>: mdr = &#123;<span class="meta">`STORE, 5&#x27;d16 &#125;; //Store the contents of accumulator</span></span><br><span class="line"><span class="number">4</span>: mdr = &#123;<span class="meta">`STORE, 5&#x27;d31 &#125;; //Store the contents of accumulator</span></span><br><span class="line"><span class="number">5</span>: mdr = &#123;<span class="meta">`BNE, 5&#x27;d6 &#125;; //Branch if result of last arithmetic operation is not zero</span></span><br><span class="line"><span class="number">6</span>: mdr = <span class="number">1</span>; <span class="comment">//contents used by another instruction</span></span><br></pre></td></tr></table></figure>

<p>My new program would take the values from the switches and add it to the current value, outputting it to the display register.<br><img src="/images/sv-microprocessor/waveform3.png" alt="Modelsim output" style="width: 100%; height: 100%"></p>
<h3 id="Extending-the-Microprocessor"><a href="#Extending-the-Microprocessor" class="headerlink" title="Extending the Microprocessor"></a>Extending the Microprocessor</h3><p>Creating a new version of the CPU, cpu3, I added the bitwise xor and bitwise not (complement) functions to act on the accumulator. This meant defining the opcodes, adding new enable lines between the ALU and sequencer, adding the functionality to the ALU and Sequencer and writing a new program in ROM to use these commands.</p>
<p>ALU: </p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (load_ACC)</span><br><span class="line"><span class="keyword">if</span> (ALU_ACC)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span> (ALU_add)</span><br><span class="line">acc &lt;= acc + sysbus;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ALU_sub)</span><br><span class="line">acc &lt;= acc - sysbus;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ALU_xor)</span><br><span class="line">acc &lt;= acc ^ sysbus;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ALU_comp)</span><br><span class="line">acc &lt;= ~acc;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>Sequencer:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">acc &lt;= sysbus;</span><br><span class="line">s8: <span class="keyword">begin</span></span><br><span class="line">MDR_bus = <span class="number">1&#x27;b1</span> ;</span><br><span class="line">ALU_ACC = <span class="number">1&#x27;b1</span> ;</span><br><span class="line">load_ACC = <span class="number">1&#x27;b1</span> ;</span><br><span class="line"><span class="keyword">if</span> (op == <span class="meta">`ADD)</span></span><br><span class="line">ALU_add = <span class="number">1&#x27;b1</span> ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="meta">`SUB)</span></span><br><span class="line">ALU_sub = <span class="number">1&#x27;b1</span> ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="meta">`XOR)</span></span><br><span class="line">ALU_xor = <span class="number">1&#x27;b1</span> ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="meta">`COMP)</span></span><br><span class="line">ALU_comp = <span class="number">1&#x27;b1</span> ;</span><br><span class="line">Next_State = s0;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>CPU:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> cpu1 <span class="variable">#( parameter WORD_W = 8, OP_W = 3)</span></span><br><span class="line"> ( <span class="keyword">input</span> <span class="keyword">logic</span> clock, n_reset,</span><br><span class="line"> <span class="keyword">inout</span> <span class="keyword">wire</span> [WORD_W-<span class="number">1</span>:<span class="number">0</span>] sysbus);</span><br><span class="line"><span class="keyword">logic</span> ACC_bus, load_ACC, PC_bus, load_PC, load_IR, load_MAR,</span><br><span class="line">MDR_bus, load_MDR, ALU_ACC, ALU_add, ALU_sub, ALU_xor, ALU_comp,</span><br><span class="line">INC_PC, Addr_bus, CS, R_NW, z_flag; </span><br></pre></td></tr></table></figure>

<p>ROM:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> (mar)</span><br><span class="line"><span class="number">0</span>: mdr = &#123;<span class="meta">`STORE, 5&#x27;d16 &#125;; //Store the contents of accumulator</span></span><br><span class="line"><span class="number">1</span>: mdr = &#123;<span class="meta">`LOAD, 5&#x27;d16 &#125;; //Load the contents of address into the accumulator</span></span><br><span class="line"><span class="number">2</span>: mdr = &#123;<span class="meta">`COMP, 5&#x27;d8 &#125;; //Complement the contents of the accumulator</span></span><br><span class="line"><span class="number">3</span>: mdr = &#123;<span class="meta">`STORE, 5&#x27;d16 &#125;; //Store the contents of accumulator</span></span><br><span class="line"><span class="number">4</span>: mdr = &#123;<span class="meta">`LOAD, 5&#x27;d16 &#125;; //Load the contents of address into the accumulator</span></span><br><span class="line"><span class="number">5</span>: mdr = &#123;<span class="meta">`XOR, 5&#x27;d9 &#125;; //Xor the contents of address with the accumulator</span></span><br><span class="line"><span class="number">6</span>: mdr = &#123;<span class="meta">`STORE, 5&#x27;d16 &#125;; //Store the contents of accumulator</span></span><br><span class="line"><span class="number">7</span>: mdr = &#123;<span class="meta">`BNE, 5&#x27;d10 &#125;; //Branch if result of last arithmetic operation is not zero</span></span><br><span class="line"><span class="number">8</span>: mdr = <span class="number">1</span>; <span class="comment">//contents used by another instruction</span></span><br><span class="line"><span class="number">9</span>: mdr = <span class="number">170</span>; <span class="comment">//contents used by another instruction</span></span><br><span class="line"><span class="number">10</span>: mdr = <span class="number">1</span>; <span class="comment">//contents used by another instruction</span></span><br><span class="line"><span class="keyword">default</span> : mdr = <span class="number">0</span>; <span class="comment">//rest of ROM is 0</span></span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>

<p>I then verified that the program was working correctly by simulating it in modelsim and going through each operation. I found that by the end of the first cycle the value in ram was 1’h55, which was to be expected when 1’hFF and 1’hAA are XORed together.<br><img src="/images/sv-microprocessor/waveform4.png" alt="Modelsim output" style="width: 100%; height: 100%"></p>
<h4 id="Github-Repository-https-github-com-sunbanett40-XOR-Decryptor"><a href="#Github-Repository-https-github-com-sunbanett40-XOR-Decryptor" class="headerlink" title="Github Repository: https://github.com/sunbanett40/XOR-Decryptor"></a>Github Repository: <a target="_blank" rel="noopener" href="https://github.com/sunbanett40/XOR-Decryptor">https://github.com/sunbanett40/XOR-Decryptor</a></h4>

      

    </section>
    
      <section class='ArticleMeta'>
          <div>
            发布于&nbsp;
            <time datetime="2021-01-24T15:02:00.000Z" itemprop="datePublished">
              2021-01-24
            </time>
          </div>
          
            <div>
              tags: 
  <li class="meta-text">
  { <a href="/tags/Microcontroller/">Microcontroller</a> }
  </li>

  <li class="meta-text">
  { <a href="/tags/Assembler/">Assembler</a> }
  </li>

  <li class="meta-text">
  { <a href="/tags/State-Machines/">State Machines</a> }
  </li>

  <li class="meta-text">
  { <a href="/tags/SystemVerilog-HDL/">SystemVerilog HDL</a> }
  </li>


            </div>
          
      </section>
    
    
</article>

  
</div>

            <footer>
    <div>© 2021 - Joseph Butterworth </div>
    <div>
        <span>
            Powered by <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a>
        </span>
        ,
        <span>
            Theme - <a target="_blank" rel="noopener" href="https://github.com/nameoverflow/hexo-theme-icalm">Icalm</a>
        </span>
    </div>
</footer>

        </div>
    </div>
</div>

<script src="/js/pager/dist/singlepager.js"></script>

<script>
var sp = new Pager('data-pager-shell')

</script>
</body>
</html>